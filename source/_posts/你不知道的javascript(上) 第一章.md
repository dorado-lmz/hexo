---
title: 你不知道的javascript(上) 第一章
date: 2017-08-05 10:03:06
tags: 你不知道的javascript
---

## JIT

#### 编译和解释

1. 为什么需要解释型语言?
对于前端工程师来说，完成代码之后立即看到结果是非常重要的。整个开发过程是不断通过验证结果来推进，而解释器启动和执行的更快，你不需要等待整个编译过程完成就可以运行你的代码。从第一行开始翻译，就可以依次继续执行了。正是因为这个原因，解释器看起来更加适合 JavaScript。这就是为什么最开始的浏览器都是用 JavaScript 解释器的原因。
关于解释器和编译器的优缺点对比请看[WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理](https://zhuanlan.zhihu.com/p/25669120)

2. javascript是解释器语言吗？
是也不是。早期javascript是解释执行的，随着前端业务逻辑复杂度不断增加，解释器的弊处就显现出来了。比如你执行一个循环，那解释器就不得不一次又一次的进行翻译，这是一种效率低下的表现。
编译器的问题则恰好相反。它需要花一些时间对整个源代码进行编译，然后生成目标文件才能在机器上执行。对于有循环的代码执行的很快，因为它不需要重复的去翻译每一次循环。
另外一个不同是，编译器可以用更多的时间对代码进行优化，以使的代码执行的更快。而解释器是在 runtime 时进行这一步骤的，这就决定了它不可能在翻译的时候用很多时间进行优化。
为此，以google,mozila为代表的浏览器厂商提出了Just-in-time 编译器。JIT是编译和解释的混合模式，在 JavaScript 引擎中增加一个监视器（也叫分析器）。监视器监控着代码的运行情况，记录代码一共运行了多少次、如何运行的等信息。

## 作用域

1. 词法作用域和动态作用域
在计算机程序设计中，变量是名字（name）与实体（entity）的绑定（binding）。一段程序代码中所用到的名字并不总是有效（或者说：可用的），而限定这个变量名字具有可用性的代码范围就是这个名字的作用域。不同的程序设计语言可能有不同的作用域和名字解析设计。同一语言内也可能存在多种作用域，随实体的类型变化而不同。作用域类别影响变量的绑定方式，根据语言使用静态作用域（词法作用域）还是动态作用域变量的取值可能会有不同的结果。
静态作用域又叫做词法作用域，采用词法作用域的变量叫词法变量。词法变量有一个在编译时静态确定的作用域。词法变量的作用域可以是一个函数或一段代码，该变量在这段代码区域内可见（visibility）；在这段区域以外该变量不可见（或无法访问）。词法作用域里，取变量的值时，会检查函数定义时的文本环境，捕捉函数定义时对该变量的绑定。大多数现在程序设计语言都是采用静态作用域规则，如C/C++、C#、Python、Java、JavaScript……
采用动态作用域的变量叫做动态变量。只要程序正在执行定义了动态变量的代码段，那么在这段时间内，该变量一直存在；代码段执行结束，该变量便消失。这意味着如果有个函数f，里面调用了函数g，那么在执行g的时候，f里的所有局部变量都会被g访问到。在静态作用域的情况下，g不能访问f的变量。动态作用域里，取变量的值时，会由内向外逐层检查函数的调用链，并打印第一次遇到的那个绑定的值。显然，最外层的绑定即是全局状态下的那个值。采用动态作用域的语言有Emacs Lisp、Common Lisp（兼有静态作用域）、Perl（兼有静态作用域），另外C/C++的宏中用到的名字，也是动态作用域。

2. javascrpt作用域
对于 var a = 10 这条赋值语句，实际上是为了查找变量 a， 并且将 10 这个数值赋予它，这就是 LHS 查询。 对于 console.log(a) 这条语句，实际上是为了查找 a 的值并将其打印出来，这是 RHS 查询。
对于 var a = 2; 这条语句，首先编译器会将其分为两部分，一部分是 var a，一部分是 a = 2;。编译器会在编译期间执行 var a，然后到作用域中去查找 a 变量，如果 a 变量在作用域中还没有声明，那么就在作用域中声明 a 变量，如果 a 变量已经存在，那就忽略 var a 语句。然后编译器会为 a = 2; 这条语句生成执行代码，以供引擎执行该赋值操作。所以我们平时所提到的变量提升，无非就是利用这个先声明后赋值的原理而已！


### 参考资料
[WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理](https://zhuanlan.zhihu.com/p/25669120)
[Lexical scoping](https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scoping)